import UIKit

//Разбор ДЗ 2

//1.1 Объявите два свойства с типом Float и присвойте им следующие значения: 3.14 и 42.0
//
//1.2 Присвойте результат сложения ваших свойств новому свойству с типом Double
//
//1.3 Выведите результат на консоль. Обратите внимание на значение результата.
let numberPi: Float = 3.14
let secondNumber: Float = 42

var sum = Double(numberPi + secondNumber)
sum = Double(numberPi) + Double(secondNumber)

print("Сумма \(numberPi) и \(secondNumber) равна \(sum)")

//2.1 Создайте свойство numberOne и присвойте ему любое положительное целочисленное значение
//
//2.2 Создайте свойство numberTwo и присвойте ему любое положительное значение меньше numberOne
//
//2.3 Создайте свойство result и присвойте ему результат деления numberOne на numberTwo
//
//2.4 Создайте свойство remainder и присвойте ему остаток от деления numberOne на numberTwo
//
//2.5 Выведите на консоль фразу: «При делении <...> на <...> результат равен <...>, остаток равен <...>», подставив вместо (<...>) свои результаты.
//
//2.6 Выведите на консоль еще одну фразу: «Результат деления <...> на <...> равен <...> <...>/<...>». В математике результатом деления 5 на 3 будет натуральная дробь 1 2/3 (здесь мы используем стандартную математическую запись в тексте, а не оператор деления). На консоль необходимо вывести именно такой результат в виде натуральной дроби. Пример: «Результат деления 7 на 3 равен 2 1/3».

let numberOne = 15
let numberTwo = 11

let result = numberOne / numberTwo
let remainder = numberOne % numberTwo

print("При делении \(numberOne) на \(numberTwo) результат равен \(result), остаток равен \(remainder)")
print("Результат деления \(numberOne) на \(numberTwo) равен \(result) \(remainder)/\(numberTwo)")

//
//3.1 Объявите свойство dayOfBirth и присвойте ему дату вашего рождения
//
//3.2 Объявите свойство monthOfBirth и присвойте ему месяц вашего рождения
//
//3.3 Объявите свойство yearOfBirth и присвойте ему год вашего рождения
//
//3.4 Необходимо рассчитать прожитое время с момента вашего рождения по текущую дату в разных единицах измерения (в годах, в месяцах, в днях и в секундах). За текущее время возьмите сегодняшнюю дату и 0 часов 0 минут. Високосные года учитывать не надо. Пусть среднее количество дней в месяце будет 30, а количество дней в году 360. Создайте все необходимые свойста, которые вам понадобятся для решения данной задачи. Для расчета всех необходимых величин используйте только арифметические операторы. Ни каких функций и условных операторов if-else использовать не нужно.
//
//3.5 Выведите результат вычислений на консоль в виде текста (n years, n months, n days and n seconds have passed since my birth). Пример: если я родился 9 ноября 1980 года, а текущая дата 29.01.20, то результат будет следующим: 39 years, 470 months, 14120 days and 1219968000 seconds have passed since my birth.

let dayOfBirth = 8
var monthOfBirth = 3
let yearOfBirth = 1999

let currentDay = 18
let currentMonth = 9
let currentYear = 2024

let secondsPerDay = 60 * 60 * 24
let daysPerMonth = 30
let daysPerYear = 360

var daysFromBirth = (currentYear - yearOfBirth) * daysPerYear // Количество дней без учета текущей даты
daysFromBirth += (currentMonth - monthOfBirth) * daysPerMonth // Количество дней с учетом текущего месяца
daysFromBirth += currentDay - dayOfBirth // Количество дней с учетом текущей даты

let secondsFromBirth = secondsPerDay * daysFromBirth
let yearsFromBirth = secondsFromBirth / secondsPerDay / daysPerYear
let monthFromBirth = secondsFromBirth / secondsPerDay / daysPerMonth

print("\(yearsFromBirth) years, \(monthFromBirth) months, \(daysFromBirth) days and \(secondsFromBirth) seconds have passed since my birth")

// *3.6 Выведите на консоль сообщение о том в каком квартале вы родились. Для этого используйте операторы сравнения, что бы сравнить номер месяца вашего рождения с одним из четырех кварталов. Например если номер месяца больше 0 и меньше или равно 3, то это будет первый квартал. Для получения результата используйте условный оператор if

if monthOfBirth > 0 && monthOfBirth <= 3 {
    print("I was born in the first quarter")
} else if monthOfBirth > 3 && monthOfBirth <= 6 {
    print("I was born in the second quarter")
} else if monthOfBirth > 6 && monthOfBirth <= 9 {
    print("I was born in the third quarter")
} else if monthOfBirth > 9 && monthOfBirth <= 12 {
    print("I was born in the fourth quarter")
} else {
    print("Error")
}


// Разберем неправильное решение задачи: дело в том, что в блоках IF мы ставим всегда четкие условия. Нужно проектировать ПО таким образом, чтобы не было неточностей при задании данных. Подобные проблемы есть и в реальных проектах, однако их находят тестировщики, которые могут задавать неверные значения для некоторых входных аргументов. Допустим, у нас есть программа "Определи свой квартал рождения" и мы, как программисты, реализовали некоторый функционал. Обычный пользователь введет верное значение, но бывают случаи, когда пользователь хотел ввести значение "12", но ввел "1W". В данном случае возникнет критическая ошибка и приложение вылетит (подобные сценарии мы разберем позднее в лекциях). Сейчас же рассмотрим житейскую ситуацию: пользователь хотел ввести значение "12" но случайно написал значение "122". Код должен был выдать предупреждение, что такого квартала не существует или же данное значеное могло быть проигнорировано. Задача с определением квартала рождения должна быть решена с ограничивающим диапазоном от 1 до 12, а далее должны быть заданы строгие условия: от 1 до 3, от 4 до 6, от 7 до 9 и от 10 до 12. В решении ниже мы задали строгое условие вхождения в конструкцию: от 0 ло 12. Все сторонние варианты мы откидываем, а далее задаем только одно значение для выявления соответствия кварталу.
monthOfBirth = 13

if monthOfBirth <= 0 || monthOfBirth > 12 {
    print("error")
} else if monthOfBirth <= 3 {
    print("I was born in the first quarter")
} else if monthOfBirth <= 6 {
    print("I was born in the second quarter")
} else if monthOfBirth <= 9 {
    print("I was born in the third quarter")
} else {
    print("I was born in the fourth quarter")
}


// Задание на вашу способность гуглить. Необходимо вычислить синус от числа 1 и округлить результат до тысячных. Для получения результата радианы искать не надо. Достаточно найти нужную функцию и она все сделает за вас.
//Подсказка: в результате должно получиться 0.841

let sinOfOne = sin(1.0)

print("Sinus by one is \(round(sinOfOne * 1000) / 1000)")
print(String(format: "Sinus by one is %.3f", sinOfOne))

// ДЗ 3


//1. Задание по кортежам
//Создайте кортеж, который содержит три элемента: ваше имя, ваш возраст и любимое число. Затем выведите на консоль каждый элемент кортежа по отдельности. Добавьте нейминг для каждого из параметров.

// Создаем кортеж с именем, возрастом и любимым числом
let person = (name: "Алексей", age: 20, favoriteNumber: 7)

// Выводим каждый элемент кортежа по отдельности
print("Имя: \(person.name)")
print("Возраст: \(person.age)")
print("Любимое число: \(person.favoriteNumber)")

//2. Задача по логике
//Представьте, что вы управляете системой доступа на конференцию. Для входа у пользователя должен быть:
//Билет на мероприятие (логическая переменная hasTicket).
//Возраст старше 18 лет (isAdult).
//Присутствовать в базе зарегистрированных пользователей (isRegistered).
//Создайте логическое выражение, которое проверяет, может ли пользователь получить доступ на конференцию.
//Дополнительно: если у пользователя есть VIP-статус (isVIP), ему можно входить даже без регистрации, но билет должен быть в любом случае.

// Логические переменные
let hasTicket = true
let isAdult = true
let isRegistered = false
let isVIP = true

// Логическое выражение для проверки доступа
let canAccessConference = (hasTicket && isAdult && (isRegistered || isVIP))

// Выводим результат проверки
print("Может ли пользователь получить доступ на конференцию? \(canAccessConference)")

var greeting = "lesson4"

// Ранее, мы с вами ознакомились с фундаментальным понятием коллекций и множеств, также поработали с кортежами и псевдонимами типов. Сегодня мы углубимся в понятие коллекций, разберем массивы и словари, затронем множества и рассмотрим операции над ними.

// массивы

// Что такое массив? Массив – это упорядоченная коллекция однотипых элементов. Массив имеет определенный размер, то есть он конечен. Доступ к элементам массива осуществляется через индексы. Напомню, что все элементы начинаются с нуля, каждый элемент массива имеет свой уникальный индекс.

// Объявим изменяемый массив с целочисленными значениями.
// Если же мы хотим объявить неизменяемый массив, то используем константу для его записи.

var DigitalArray = [1, 2, 3, 4, 5]

// Мы объявили массив с элементами от 1 до 5? Нам это напоминает конструкцию диапазона, мы также можем задать массив при помощи диапазона. Создадим неизменяемый массив с элементами от 1 до 5.

let DigitalCloseRangeArray = Array(1...5)

// сравним заданный массив руками и массив, заданный через диапазон

if DigitalArray == DigitalCloseRangeArray {
    print("Массивы равны")
} else {
    print("Массивы не равны")
}

// Если же мы зададим через конструкцию задания диапазона напрямую и попытаемся сравнить массивы, то получим ошибку. Дело в разных типах, если же мы запросим тип у константы DigitalCloseRangeArray и у константы CloseRangeArray, то убедимся, что типы разные. Следовательно, мы используем инициализатор массива array() для добавления последовательности в массив.

let CloseRangeArray = [1...5]
type(of: DigitalCloseRangeArray) // Array<Int>.Type
type(of: CloseRangeArray) // Array<ClosedRange<Int>>.Type

// Перейдем к следующей части определения – доступ к элементам массива. Давайте обратимся к массиву DigitalCloseRangeArray и запросим первый элемент коллекции (первый элемент будет иметь индекс 0).

DigitalCloseRangeArray[0] // 1

//Мы обратились к объявленному хранилищу DigitalCloseRangeArray и в квадратных скобках указали нужный нам индекс элемента и получили этот элемент. Данный метод является возвращаемым, поэтому резульат мы можем записать в какую-либо переменную или константу для дальнейших манипуляций.

// ЗАДАЧА: у нас был создан массив со значениями от 1 до 5, по какому индексу хранится значение 4? Ответ: индекс 3, так как смещение индекса идет на единицу.

let someStrings = ["some string one", "some string two", "some string three"]

// Сделаем небольшую остановку, думаю, вы заметили, что все заданные переменные и константы имеют одинаковый стиль написания, например someValue. Именование каких-либо объектов в языке swift регламентированно компанией Apple. Стиль подобного наименования называется Camel Case из-за схожести написания слов с горбами верблюда.

// Если же мы зажмем клавишу option и наведем на имя нашего массива, то получим определенный тип. Возвращаемся к нашему определению и вспоминаем, что массив – это коллекция однотипных элементов.
// Массив – самый непроизводительный из всех коллекций, так как при изменении массива компилятору необходимо переиндексировать все его элементы. Желательно использовать неизменяемые массивы, так как индексы задаются единожды при инициализации элементов массива.

// Вернемся к макссивам и создадим некоторый массив с символьными значениями

// Неизменяемый массив с типом данных Character
let someCharacters: [Character] = ["Й", "О", "Д"]

// Вопрос: какой тип коллекции будет, если мы передадим туда символы "Й", "О", "Д"? Тип будет строковой, об этом мы говорили с Вами на предыдущих лекциях. В программировании все взаимосвязано, вы будете постоянно встречаться с терминами либо объектами, которые мы изучали в самом начале. Именно поэтому очень важно повторять некоторые правила написания кода, чтобы они лучше закрепились на практике.

// Объявим пустой массив с типом Int
var someIntegers: [Int] = []

// Присвоим некоторые целочисленные данные в массив (Если бы мы объявили не переменную, а константу, то уже бы не смогли в него инициализировать какие-либо данныые, так как изначально мы передали в хранилище пустой массив. Разберем это на небольшом примере: объявим константу с именем AppendElementsInLet и укажем яввно тип Array<Int>. После этого, на следующей строке бы обращаемся к нашей переменной и передаем в нее массив с целочисленными значениями.

let AppendElementsInLet: Array<Int>
AppendElementsInLet = [10, 15, 20]
// Вернемся к нашему массиву someIntegers, присваиваем ему целочисленные значения 10, 15 и 20.
someIntegers = [10, 15, 20]

// Если же мы хотим радикально изменить данные массива, то мы можем передать в наш массив новый массив, тем самым мы перезапишем значения. Запись таким методом уничтожает предущие данные в хранилище. 

someIntegers = [9, 18, 27]

//В изменяемый массив мы можем добавлять новые элементы. Есть несколько способов: низкоуровневые и высокоуровневые. Сейчас мы добавим два элемента к нашему массиву через инкремент.

someIntegers += [36, 45]

// Выведем наши элементы массива на консоль
print(someIntegers)

// Наши новые элементы добавились в конец нашего массива.


// Теперь разберем более высокоуровневые конструкции добавления элементов в массив. Первый способ, добавление через метод append. В качестве аргумента метода append передаем значение, которое необходимо добавить. Такой метод часто используется в циклах, которые мы также в будущем разберем.

someIntegers.append(54)

print(someIntegers)

// Более приятным способом добавления элементов в массив является метод insert. В аргументах данного метода мы передаем элемент коллекции, который хотим добавить и индекс, куда мы хотим поместить наш элемент. Допустим, в нашу последовательность следовало бы добавить число 1 в нулевой индекс.
someIntegers.insert(1, at: 0)
print(someIntegers)

//  Мы можем объединить два массива. Создадим массив integersArray и добавим к нему массив, состоящий из двух элементов.
var integersArray = someIntegers + [63, 72]
print(integersArray)

//  Теперь поговорим, каким образом можно удалить элементы из массива. Для удаления последнего элемента коллекции используется метод removeLast(), в скобки которого нет необходимости передавать какой-либо аргумент (Почему так происходит, мы разберем на лекции с функциями)

//  Удалим последний элемент из массива integersArray
integersArray.removeLast()
print(integersArray)
//  При удалении элемента, метод возвращает удаленное значение, которое мы можем записать в переменную либо константу для дальнейших манипуляций над ним. Запишем удаленный элемент в константу lastValueFromArray, после оператора инициализации вызовем наш массив integersArray и через точку обратимся к методу removeLast()

let lastValueFromArray = integersArray.removeLast()
// выведем наш измененный массив в консоль:
print(integersArray)

// Последние два элемента были удалены из нашего массива при помощи метода removeLast()

// Теперь удалим первый элемент нашего массива при помощи методаremoveFirst() (в скобки также не нужно передавать аргумент) и выведем коллекцию в консоль:
integersArray.removeFirst()

// Выведем результат на консоль
print(integersArray)

// Воспользуемся методом remove, который принимает в качестве аргумента индекс элемента, который нам необходимо удалить.
integersArray.remove(at: 1)

// Выведем массив после удаления первого элемента.
print(integersArray)

//  Среди методов есть один из самых частоиспользуемых – это метод count. Данный метод позволяет определить количество элементов в массиве и вывести это значение в виде числа.
integersArray.count

// Для более радикальных слушаетелей разработчики языка добавили метод removeAll() для удаления всех элементов из массива.
integersArray.removeAll()

// ЛИБО, мы можем передать пустой массив вызванной переменной и наш массив будет обнулен.
integersArray = []

// После удаления всех элементов наш массив пуст, для того, чтобы код автоматически смог проверять "пуст ли массив" используется метод isEmpty, которое возращает логическое значение.

integersArray.isEmpty


integersArray = [10, 20, 30]

// В некоторых случаях бывает необходимо определить индекс элемента, по которому находится какой-либо элемент. Для этого применяется метод firstIndex(of: 30) с аргументом в виде искомого элемента. Если же мы передадим в аргумент отсуствующий элемент в массиве, то получим значение nil. Данное значение будет подробно разобрано на будущей лекции с опциональными типами, однако сейчас можно сказать следующую парадигму: nil – это не ноль, это отсутствие присутствия элемента, когда ноль – это присутствие отсутсвия элемента.

integersArray.firstIndex(of: 30)
integersArray.firstIndex(of: 40)  //nil

// При попытке найти значение "40" в массиве, состоящего из элементов – 10, 20 и 30, мы получим значение nil.


// Для того, чтобы изменить значение конкретного элемента, то вызываем нашу переменную и ставим квадратные скобки в которых пишем индекс заменяемого элемента, после чего ставии символ инициализации и новое значение для этого индекса.

integersArray[2] = 50

// Выведем получившийся массив в консоль
print(integersArray)

//  Также, есть возможность создать массив с заданием количества повторяющихся элементов в массиве. Зададим троекратное ура в массиве.

var repeatingArray = Array(repeating: "УРА", count: 3)
print(repeatingArray)

//Мы с Вами разобрали базовые методы массивов, теперь перейдем к практическому заданию:

//1. Объявите массив, состоящий из 10 целочисленных значений
//2. Убедитесь (при помощи метода), что элементов действительно 10.
//3. Добавьте в ваш массив 3 новых элемента
//4. Удалите из вашего массива первый элемент
//5. Удалите из вашего массива пятый элемент
//6. Добавьте на место пятого элемента значение 15
//7. Удалите последний элемент из массива
//8. Удалите все элементы из массива.

// Расширенные действия над массивами
// Допустим, у рас есть лотерейные номера, занесенные в массив. Нам нужно из перемешать и выбрат случайный элемент. Для решения этой задачи объявим массив с билетами:

var tickets = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65]

var users = ["Галинов", "Даниленок", "Захаров", "Крючкова", "Кузькин", "Курбатова", "Лапшин", "Любимов", "Михайлова", "Потифорова", "Тимофеев", "Крымин"]


let count = min(tickets.count, users.count)
// Выдадим каждому студенту билет

for i in 0..<count {
    print("Фамилия: \(users[i]), Номер билета: \(tickets[i])")
}
//Все элементы нашего массива отсортированы, а нам нужно их переменать. Воспользуемся метолом shuffle()
tickets.shuffle()
print(tickets)

// И выберем победителя через хитрую конструкцию

let winner = tickets[Int.random(in: 1...count)]

print("Поздравляем, побелитель с номером \(winner)")


// Множества
// Хранят в себе неупорядоченные, но при этом уникальные значения одного типа

// Мы с Вами уже затрагивали тему явного и неявного задания типов. Для множеств нужно явно укзаыывать тип, иначе мы получим массив.
// Создание множества с типом String
let strings: Set = ["a", "a", "a", "b", "c"]

// Мы передали значения в наше множество, теперь если мы захотим его распечатать, то какие значения мы получим?
print(strings)
// У множеств нет индексов, поэтому множества более производительнее массивов.
// Создание пустого множества с типом Character
var characters: Set<Character> = []

// Добавление нового элемента в множество
characters.insert("b")
characters.insert("b")

// Проверка на наличие определенного элемента во множестве
characters.contains("b")

// Сортировка с использованием метода sorted() для последующей итерации по множеству
characters = ["a", "a", "a", "b", "c"]
let chars = characters.sorted(by: >)

//словари


// Неупорядоченные коллекции, которые хранят в себе пары «ключ-значение». Тип ключа словаря может отличаться от типа значения. При этом сами ключи и значения должны быть одного типа

// Словарь очень сильно похож на физический словарь, допустим англо-русский, рассмотрим пример:

let dictionary = ["Hello": "Привет", "Friday": "Пятница", "Exam": "Экзамен"]

dictionary["Friday"]
dictionary["Пятница"]

let usersDictionary = [1: "Tim Cook", 2: "Taylor Swift"]

usersDictionary[2]

// Создание пустого словаря с типом [String: String]
var washQueue: [String: String] = [:]

// Наполнение словаря данными
washQueue = ["EO82BA": "Red Toyota", "С127MT": "Gray BMW X5"]

// Изменение значения для ключа
washQueue["EO82BA"] = "Red Camry"

// Изменение значения с сохранением старого значения
let oldValue = washQueue.updateValue("White BMW X5", forKey: "С127MT")

// Добавление новой пары ключ-значение
washQueue["M566PA"] = "Chavralet Niva"

// Удаление значения по ключу с сохранением значения
washQueue.removeValue(forKey: "EO82BA")

washQueue.count
washQueue.removeAll()