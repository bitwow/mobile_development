import UIKit

var greeting = "Lesson 5"

// На прошлой лекции мы не успели разобрать несколько кодовых конструкций, поэтому сегодня затронем предыдущую тему с массивами.

// Недавно мы с Вами обсуждали, что строка – это массив. Однако, мы также определили, что нет прямого и удобного способа обратиться к объекту (то есть символу) намрямую через индекс. С математической точки зрения все теоремы должны быть длказуемы, давайте докажем, ято строка это массив. Объявим строку и вызовем инициализатор String, в аргументе которого будет передан массив символов, а после выведем получившийся результат. Что же мы получим в итоге на консоли? Ответ: Мы полуим строку, содержащую целиковое слово "Hello".

let string = String(["H", "e", "l", "l", "o"])
print(string)
string.count
// Также, мы можем пользоваться методами, которые мы использовали для массивов, напимер: определим количество элементов в строке или же найдем нужный элемент.
string.count
string.contains("h") // Вместо возвращаемого индекса будет возвращено буливое значение. В жанном случае false, так как "H" и "h" – это разные символы

// Мы с Вами уже беседовали про графем-скаляры, давайте рассмотрим их применение в жизни. Все знают, что в стандарте юникод есть место для эможджи. Некоторые эмоджи могут быть разных цветов, но хранить каждую вариацию объекта невохможно. Каким же оразом тут помогают графем-скаляры. Рассмотрим эмодзи мужчины (стандартно, он желтого цвета, однако есть 6 различных вариаций (цветов кожи)
let manEmoji = "\u{1F468}"
let brownEmoji = "\u{1f3fd}"
let emojiResult = "\u{1F468}\u{1f3fd}"

// В константе emojiResult мы получили мужчину с коричневым цветом кожи.

// Также, я оюещал, что мы с Вами затронем диапазоны в массивах, объявим массив с целочисленными значениями и выведем диапазон искомых значений
//var numericArray = [0...20] //– таким образом мы задаем тип диапазона
var numericArray = Array(0...20) // - таким образом мы задаем тип массива с инициализатором array() для взаимодействия с целочисленными типами

let subArray = numericArray[5...10]
print("Элементы с 5 по 10 индексы: \(subArray)")

// Супер, мы смогли извлечь значения из нашего массива. Если мы с Вами посмотрим на возвращаемый тип в константе subArray, то увидим: "ArraySlice of 6 Int elements". Даже сейчас, после выполнения операции вывода диапазона значений, мы смогли столкнутьмся с новым типом. ArraySlice – это подмножество исходного массива. Данный тип нужно использовать крайне осторожно, так как он не копирует новое значение, а выдает ссылку на подмножество исходного мнодества в памяти. Данный тип является ссылочным и при внесении изменений в ArraySlice будет затронута исходная коллекция.

//Рассмотрим еще несколько операций над массивами:

// При помощи метода suffix() мы получим с вами возвращаемый массив с элементами из корневого (в качестве аргумента принимается целочисленное значение, это значение дает возможность отсчитать количество выводимых элементов массива с конца). Допустим, из нашего массива numericArray мы хотим вывести 5 последних элементов

let subArraysuffix = numericArray.suffix(5)
print("Пять последних элемента массива: \(subArraysuffix)")

//Методы First и Last позволяют вывести первый и последний элементы из массива, напимер.

//print("Первый элемент массива: \(numericArray.first), второй элемент массива: \(numericArray.last)") // Первый элемент массива: Optional(0), второй элемент массива: Optional(20)
print("Первый элемент массива: \(numericArray.first ?? -1), второй элемент массива: \(subArraysuffix.last ?? -1)")

// Методы DropFirst и DropLast позволяют отбросить первый и последний элементы массива, а после вернуть новое значение в константу или переменную. (Подобные методы не вносят изменений в исходную коллекцию)

print("Удалим первый элемент коллекции и вернем массив: \(numericArray.dropFirst())")
print("Удалим последний элемент коллекции и вернем массив: \(numericArray.dropLast())")
print("Исходный массив: \(numericArray)")

// Результат – мы внесли изменения в копии массива numericArray, но исходно сам массив не был изменен.

// Методы min() и max() позволяют вывести минимальный и максимальный элемент коллекции:

numericArray.min()
numericArray.max()

// Метод reverse() позволяет изменить порядок элементов (переворот массива)

numericArray.reverse()
print(numericArray)

// Метод sort() и sorted() сортируют коллекцию с элементами в порядке возрастания. Методы, которые заканчиваются на -ed не изменяют исходную коллекцию, а возвращают измененную копию исходного объекта. Исходный объект не изменяется
print("___________________")
print("Коллекция была отсортирована методом sorted(): \(numericArray.sorted())")
print("Исходная коллекция: \(numericArray)")
print("Коллекция была отсортирована методом sort(): \(numericArray.sort())")
print("Исходная коллекция: \(numericArray)")

// Также, в сортировке можно передать знак сравнения и этим мы определим порядок сортировки (от меньшего к большему или от большего к меньшему)
// sorted(by: >): НАПИСАТЬ СИГНАТУРУ
print("Коллекция была отсортирована методом sorted(by: >): \(numericArray.sorted(by: >))")

// Метод randomElement() позволяет получить случайный элемент массива

numericArray.randomElement()

// Мы подошли к концу изучения массивов. Напомню, что массивы необходимы для хранения множемтва однотипых элементов, также массивы могут быть изменяемыми и неизменяемыми.

// Также, после более детального изучения массивов мы можем более детально углубиться и в множества. На прошлом занятии мы рассмотрели множества, сегодня мы разберем подмножества множеств (аналогичная тема дискретной математики)

// Объявим три множества

// множество с нечетными цифрами
let oddDigits: Set = [1, 3, 5, 7, 9]
// множество с четными цифрами
let evenDigits: Set = [0, 2, 4, 6, 8]
// множество со смешанными цифрами
let differentDigits: Set = [3, 4, 7, 8]

// Во множествах oddDigits, evenDigits и differentDigits существуют как уникальные для каждого из них, так и общие элементы. Для каждой пары множеств можно произвести следующие операции (рис. 7.2): получить все общие элементы (intersection(_:));
//получить все непересекающиеся (не общие) элементы (symmetricDiffe- rence(_:));
//получить все элементы обоих множеств (union(_:));
//получить разницу элементов, то есть элементы, которые входят в первое множество, но не входят во второе (subtracting(_:)).

//При использовании метода intersection(_:) возвращается множество, содержащее значения, общие для двух множеств

let intersection = differentDigits.intersection(oddDigits)
intersection // {3, 7}

// Для получения всех непересекающихся значений служит метод symmetricDifference(_:)

let exclusive = differentDigits.symmetricDifference(oddDigits)
exclusive //{4, 8, 1, 5, 9}

//Для получения всех элементов из обоих множеств (их объединения) применяется объединяющий метод union(_:)

let union = evenDigits.union(oddDigits)
union //{8, 4, 2, 7, 3, 0, 6, 5, 9, 1}

//Метод subtracting(_:) возвращает все элементы первого множества, которые не входят во второе

let subtract = differentDigits.subtracting(evenDigits)
subtract // {3, 7}

// Объявим еще три множества

let firstSet: Set = [1, 2, 3, 4, 5]
let secondSet: Set = [1, 3]
let thirdSet: Set = [5, 6, 7, 8]

// Множество firstSet — это надмножество для secondSet, так как включает в себя все эле- менты из secondSet. В то же время множество secondSet — это подмножество для firstSet, так как все элементы secondSet существуют и в firstSet. Множества thirdSet и secondSet являются непересекающимися, так как у них нет общих элементов, а множества firstSet и thirdSet — пересекающиеся, так как имеют общие элементы.

// Два множества считаются эквивалентными, если у них один и тот же комплект элементов. Эквивалентность множеств проверяется с помощью оператора эквивалентности (==)

// создаем копию множества
let copyOfsecondSet = secondSet
/* во множествах bSet и copyOfBSet одинаковый состав
 элементов. Проверим их на эквивалентность */
secondSet == copyOfsecondSet // true

// Метод isSubset(of:) определяет, является ли одно множество подмножеством другого, как bSet для aSet. При этом он возвращает true, даже если множества равны

secondSet.isSubset(of: firstSet) // true

// Метод isSuperset(of:) вычисляет, является ли множество надмножеством для другого, как aSet для bSet. При этом он возвращает true, даже если множества равны

firstSet.isSuperset(of: secondSet)  // true

//Метод isDisjoint(with:) определяет, существуют ли в двух множествах общие элементы, и в случае их отсутствия возвращает true

secondSet.isDisjoint(with: thirdSet) // true

// Методы isStrictSubset(of:) и isStrictSuperset(of:) определяют, является множество подмножеством или надмножеством, не равным указанному множеству

secondSet.isStrictSubset(of: firstSet) // true
firstSet.isStrictSuperset(of: secondSet) // true var aSet: Set = [1, 2, 3, 4, 5]

// На этом мы закончим знакомство с множествами. Множества применяютмся там, где есть необходимость хранения однотипных элементов в неупорядоченном порядке

// ПРАКТИЧЕСКАЯ РАБОТА №2
// 1
// Создайте два множества: setA и setB. setA должен содержать числа от 1 до 10, а setB — числа от 5 до 15.
// 2
// Найдите пересечение множеств setA и setB.
// Найдите объединение множеств setA и setB.
// Найдите разность множеств setA и setB.

//3
//Проверьте, является ли setA подмножеством setB.
//Проверьте, является ли setB подмножеством setA.

//4
//Найдите симметрическую разность множеств setA и setB.
//Проверьте, являются ли множества setA и setB равными.
//5
//Выведите результат в форматированном виде
//print("Пересечение: \(intersection)")
//print("Объединение: \(union)")
//print("Разность: \(difference)")
//print("setA является подмножеством setB: \(isSubsetA)")
//print("setB является подмножеством setA: \(isSubsetB)")
//print("Симметрическая разность: \(symmetricDifference)")
//print("Множества равны: \(isEqual)")


// Операторы управления

// Утверждения

// Синтаксис утверждений максимально прост и понятен: assert(проверяемое_выражение, отладочное_сообщение)

// Рассмотрим пример, если пользователю есть 18 лет, то мы продолжим выполнение программы, в противном случае оставливаем ход выполнения и выводим сообщение в консооль "доступ запрещен"

let userYears = 19
//assert(userYears >= 18, "доступ запрещен")

// __lldb_expr_169/lesson_5.playground:182: Assertion failed: доступ запрещен

// Оператор IF

// Оператор if предлагает проверку условия на истинность, если условие – истина, то выполняет код внутри тела оператора if

// решим предыдушую задачу через if

if userYears < 18{
    print("доступ запрещен")
}

// Сейчас мы с Вами воспользовались упрощенной конструкцией оператора if

// ЗАДАЧА: реализуйте вывод сообщения "Добро пожаловать \(name)", если имя пользователя "Admin"

// решение
let nameUserAccount = "Admin"
if nameUserAccount == "Admin"{
    print("Добро пожаловать \(nameUserAccount)")
}

// Расширим возможности нашего сокращенного if до полноценного. Возьмем две ветки выполнения кода – если человеку есть 18 лет, то разрешим ему доступ, если же нет – запретим доступ.

if userYears < 18{
    print("доступ запрещен")
} else {
    print("доступ разрешен")
}

// ЗАДАЧА: расширьте предыдущую задачу, добавив сообщение "отказано в доступе"

// Если же мы с Вами хотим сделать больше условий, то берем расширенную версию оператора if

if true {
    print(true)
} else if true{
    print(true)
}

// в чем ошибка данного кода?

// ЗАДАЧА: расширьте предыдущую задачу, добавив еще одного пользователя.

var temperature = 100

if temperature < 18 { // False
    print("На улице холодно")
} else if temperature < 25 { // True
    print("На улице тепло")
} else {
    print("На улице очень жарко")
}

var weather = ""

if temperature < 18 {
    weather = "На улице холодно"
} else {
    weather = "На улице тепло"
}

// condition ? some code : some code

weather = temperature < 18 ? "На улице холодно" : "На улице тепло"

print(weather)

// switch
//
//switch значение для сопоставления {
//case значение 1:
//    инструкция для первого значения
//case значение 2, значение 3:
//    инструкция для второго и третьего значения
//default:
//    инструкция, если совпадений с шаблонами не найдено
//}

var grade: Character = "A"

if grade == "A" {
    print("Excellent")
} else if grade == "B" {
    print("Good")
} else if grade == "C" {
    print("Satisfactory")
} else if grade == "D" {
    print("Could be better")
} else {
    print("Invalid grade")
}

grade = "b"

if grade == "A" || grade == "a" {
    print("Excellent")
} else if grade == "B" || grade == "b" {
    print("Good")
} else if grade == "C" || grade == "c" {
    print("Satisfactory")
} else if grade == "D" || grade == "d" {
    print("Could be better")
} else {
    print("Invalid grade")
}

switch grade {
case "A", "a":
    print("Excellent")
case "B", "b":
    print("Good")
case "C", "c":
    print("Satisfactory")
case "D", "d":
    print("Could be better")
default:
    print("Invalid grade")
}

// Соответствие диапазону


let approximateCount = 146
let countedThings = "moons orbiting Saturn"
var naturalCount = ""

switch approximateCount {
case ..<0:
    print("Error")
case 0:
    naturalCount = "zero"
case 1:
    naturalCount = "one"
case 2..<5:
    naturalCount = "a few"
case 5...11:
    naturalCount = "several"
case 12...99:
    naturalCount = "dozens of"
default:
    naturalCount = "many"
}

print("There are \(naturalCount) \(countedThings)")



