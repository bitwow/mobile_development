import UIKit
import Foundation

// Если Вы встретили два слэша, то это значит, что впереди комментарий или закомментированный блок кода, который был изменен на лекции и его предыдущая версия сохранена в комментарии.

var greeting = "Lesson 2"
//Оператор присваивания – это символ =, позволяет поместить значение какого-либо типа (any type) в созданное хранилище.

//Создадим переменную helloGroup, но не будем инициализировать никакого значения. Если же мы не укажем тип переменной (хранилища), то компилятор выдаст ошибку. Объявить константу либо переменную можно лишь с указанием типа (в таком случае можно будет инициализировать значение после создания константы).

//let helloGroup: String
var helloGroup: String
helloGroup = "Hello Students"
print(helloGroup)
// Мы изменили значение переменной, если же мы попробовали изменить значение в константе, то получили бы ошибку: "Immutable value 'helloGroup' may only be initialized once". XCode предложит заменить ключевое слово 'let' на 'var': "Change 'let' to 'var' to make it mutable"
helloGroup = "Goodbye Students"
print(helloGroup)

// Ниже представлен код, который показывает парадигму работы value type (значимых типов). Значения значимых типов передаются копированием, а не ссылкой.
var parametr1: Int = 10
var parametr2 = parametr1
parametr2
parametr2 + 5
parametr1

// Параметр 1 не был изменен, так как мы вносили изменения в его копию – параметр 2. В оперативной памяти параметр 1 и параметр 2 – два отдельных и независимых хранилища.

let result = parametr1 * parametr2
// Третья переменная result содержит в себе значения умножения, полученное от перемножения копий – параметр 1 и параметр 2

// Также, отмечу, что Swift является языком со строгой типизацией. Тип параметра мы не можем изменить после его инициализации. Тип указывается единожди при объявлении переменной или же константы.
var numberPhone = 1234
numberPhone = 5678
//numberPhone = "+7qwerty"
// Альтернативный тип мы не смогли передать в переменную (перезаписать), Cannot assign value of type 'String' to type 'Int'.

// Бывают ситуации, когда необходимо провести операции между разными типами данных (в рамках одного типа (допустим, среди целочисленных значений, среди целочисленных значений и дробных, среди целочисленных, дробных и строковых типов), тогда можно воспользоваться функцией приведения типов.

// Возьмем два значения: 365 и 0.25, значение 365 относится к целым числам, а 0.25 к дробным.

let year = 365
let day = 0.25
// Для того, чтобы провести операцию сложения нам потребовалось привести константу year к типу double (или же константу day к типу Int, однако от этого нет смысла)
print("Value = \(Double(year) + day)")

//Типы данных
// Типы данных бывают нескольких типов, в рамках данной лекции рассмотрим базовые (фундаментальные) типы данных.

// Числовые
// Int, Float, Double

var integer: Int = -63646783
var unsignetInteger: UInt = 80
// Выведем минимальные и максимальные значения целочисленных типов
Int8.min      //-128
Int16.min     //-32 768
Int32.min     //-2 147 483 648
Int64.min     //-9 223 372 036 854 775 808
Int8.max      //127
Int16.max     //32 767
Int32.max     //2 147 483 647
Int64.max     //9 223 372 036 854 775 807

UInt.min      //0
UInt8.max     //255
UInt16.max    //65 535
UInt32.max    //4 294 967 295
UInt64.max    //18446744073709551615

// Блок со звездочкой

/*
Каким образом определяется размерность числа?
 
 Разберем на примере типа Int8, последняя числа которого обозначает битность. Для данного типа обеспечивается разрешающая способность в 8 бит. Как определить, какое количество значений может быть помещено в 8 бит?
 
 Начнем с того, что 8 – это количество битов, которыми может быть задано число. Исходя из этого определим минимум и максимум 8 битного числа.
 
 00000000 – значение 0, если перевести в десятичную систему счисления.
 11111111 – значение 255, если перевести в десятичную систему счисления. (Почему 255? Все просто, диапазон чисел от 0...255, соотвественно всего 256 значений.
 Исходя из этого делаем вывод, что для беззнакового числа UInt8 минимальное значение 0, а максимальное – 255 (возводим в 8 степень, так как нет знака).
 
 Для знаковых чисел расчет немного сложнее:
 
 Старший бит в последовательности (первый слева) используется для определения знака, исходя из этого выведем минимальное и максимальное значение для Int8.
 
 10000000 – значение -128, если перевести в десятичную систему счисления.
 01111111 – значение 127, если перевести в десятичную систему счисления.

 Исходя из этого делаем вывод, что для знакового числа Int8 минимальное значение -128, а максимальное 127 (возводим в 7 степень, так как единица уходит на знак).
 */


// Double Float
// число double обеспечивает двойную точность, до 15 знаков после запятой (когда float – до 6 знаков)

var double = 3.141592653589793 //3,141592653589793
var float: Float = 3.141592653589793 //3,141593


// Строковые
// Если мы задаем значение без указания его типа, компилятор автоматически выберет значение string для строки, даже если там будет только один символ.
var string = "Hello"
var character: Character = "H"

// Дефолтные значения: Int64, Double, Bool, String
// Если же нам нужен только определенный тип, то указываем его вручную. Допустим, если мы хотим указать хранилище для хранения возраста пользователя, то можно использовать UInt8. Его целиком и полностью хватит для наших задач, так как нет ни единого человека с возрастом более 255 лет или же с отрицательным значением.

var age: UInt8 = 25

// Логические

// Логический тип принимает только лишь два значения: true и false. Логика – базовый элемент в работе компьютера. Об этом можно почитать отдельно: http://al-tm.ru/stati/stati-po-printeram/logicheskie-elementyi-kompyuternoj-texniki-(likbez)

var boolian: Bool = true

//Арифметические операторы:
// В обзей базе программирования лежат простейшие арифметические операции:
let a = 9
let b = 5

a + b
a - b
a * b
a / b


//Составной оператор присваивания:
// Составные операторы позволяют использовать декремент и инкремент, а также производить операции с упрощенным синтаксисом.
var count = 10

count += 1
count -= 1
count *= 1
count %= 1


//Оператор остатка от деления:

var num1 = 19
var num2 = 4

var resultDivision = num1 / num2
var resultModulo = num1 % num2

//Каким образом работает деление:
//Если мы поделим целые числа, то остаток от деления будет отброшен и  округление не предусмотрено. Если же мы хотим получить остаток от делен ия, то нам необходимо использовать типы с плавающей точкой.
// В swift предусмотрен способ получения остатка от деления, допустим, мы хотим получить остаток от деления 19 на 4. Получим в ответе 3, так как мы заполняем 4 блока (1,2,3,4)(5,6,7,8)(9,10,11,12)(13,14,15,16), а остаток (17,18,19,_) возвращается. Мы не смогли заполнить последний блок и вернули остаток на консоль. Подобный способ проведения математической операции необходим для решения некоторых задач, которые будут рассмотрены в следующих лекциях.

//Операторы сравнения:

// Воспользуемся ранее объявленными переменными, выведем их значения
num1    // 19
num2    // 4

num1 == num2  // Num1 сравним с Num2 – false
num1 != num2  // Num1 НЕ равен Num2 – true
num1 > num2   // Num1 больше Num2 – true
num1 < num2   // Num1 меньше с Num2 – false
num1 >= num2  // Num1 больше либо равно Num2 – true
num1 <= num2  // Num1 меньше либо равно Num2 – false

//Оператор логического НЕ:
// ! – обозначение
//Обратимся к ранее объявленной логической переменной.
boolian // Значение true

!boolian // // Значение false, так как НЕ истина – это ложь.

// Решим задачу: если переменная allow – истина, то мы выведем на консоль Hello, если же ложь, то выведем Goodbye. Для решения задачи используем условную конструкцию if-else.

var allow = false

var printMessage = "Hello"
var printMessage2 = "Goodbye"

if !allow{
    print(printMessage2)
} else {
    print(printMessage)
}

//Оператор логического И:
// && – обозначение
// Решим задачу: Представим, что у нас есть дверь. Дверь можно открыть ключем и сканированием лица. Если у нас нет ключа или же скана лица в базе – то дерь останется закрытой. Воспользуемся вновь конструкцией if-else.
let key = false
let face = true

if key && face{
    print("Good")
}
//Оператор логического ИЛИ:
// || – обозначение
// Решим вновь предыдущую задачу, только изменим условие: если у нас есть ключ ИЛИ наше лицо есть в базе, то мы можем открыть дверь.
if key || face{
    print("Good")
}


//Работа со строками:
//
//Объявление и инициализация строк

//Конкатенация строк:

var nameUser = "Alexey"
var greetingUser = "Hello!"

//Конкатенация строк:
let greetingUserPrint = nameUser + "–" + greetingUser
//Интерполяция строк:
let greetingUserInterpolation = "\(nameUser) – \(greetingUser)"

// Советую использовать интерполяцию, так как конкантенация – это устаревший метод, пришедший из языков семейства С.


//Многострочные литералы

var profileUseer = """
    full name \(nameUser)
    greeting \(greetingUser)
    company: University ITMO
    post: student
"""
print(profileUseer)

// Числа можно задавать в десятичной, двоичной, восьмиричной, шестнадцатиричной системах.

let decimalNumber = 17

let binaryNumber = 0b10001

let octalNumber = 0o21

let hexNumber = 0x11

// Для лучшего понимания числа можно его разделять андерскорами (нижним подчеркиванием)
var million = 1_000_000
print(million)

// Альтернативное задание чисел (используется редко и для решения инженерных задач).
var decimalDouble = 12.12875

let exponentDouble = 1.21875e1

let hexDouble = 0xC.3p0


// Вернемся к работе с дробными числами, решим задачу. После каждой транзакции по карте мы начисляем на счет 0.1 условной валюты. Для хранения такой валюты мы используем хранилище myWallet с типом double. Спустя три транзакции мы получаем значение: 0.30000000000000004. Дело в том, что 0.1 это 0.00011001100110011. Блок 0011 повторяется бесконечное количество раз.
var myWallet: Double = 0
let incomeAfterOperation = 0.1

myWallet += incomeAfterOperation
print(myWallet)
myWallet += incomeAfterOperation
print(myWallet)
myWallet += incomeAfterOperation
print(myWallet)

// Решение подобной задачи возможно при использовании типа данных decimal. Тип decimal в отличие от float и double хранится как целое число и смещение десятичной запятой. Например число 12.75 хранится как 1275 и значение смещения 2. И такие значения дают большую точность, чем сумма дробей.

var decimalWallet: Decimal = 0

let income: Decimal = 0.1

decimalWallet += income
print(decimalWallet)
decimalWallet += income
print(decimalWallet)
decimalWallet += income
print(decimalWallet)

// Ошибка ушла, результат получен верный. Мы спасли крипто-площадку от потенциальной потери денег.
